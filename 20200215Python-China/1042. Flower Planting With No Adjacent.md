### [1042\. Flower Planting With No Adjacent](https://leetcode.com/problems/flower-planting-with-no-adjacent/)

Difficulty: **Easy**


You have `N` gardens, labelled `1` to `N`.  In each garden, you want to plant one of 4 types of flowers.

`paths[i] = [x, y]` describes the existence of a bidirectional path from garden `x` to garden `y`.

Also, there is no garden that has more than 3 paths coming into or leaving it.

Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.

Return **any** such a choice as an array `answer`, where `answer[i]` is the type of flower planted in the `(i+1)`-th garden.  The flower types are denoted <font face="monospace" style="display: inline;">1</font>, <font face="monospace" style="display: inline;">2</font>, <font face="monospace" style="display: inline;">3</font>, or <font face="monospace" style="display: inline;">4</font>.  It is guaranteed an answer exists.


**Example 1:**

```
Input: N = 3, paths = [[1,2],[2,3],[3,1]]
Output: [1,2,3]
```


**Example 2:**

```
Input: N = 4, paths = [[1,2],[3,4]]
Output: [1,2,1,2]
```


**Example 3:**

```
Input: N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
Output: [1,2,3,4]
```

**<span style="display: inline;">Note:</span>**

*   `<span style="display: inline;">1 <= N <= 10000</span>`
*   `<span style="display: inline;">0 <= paths.size <= 20000</span>`
*   No garden has 4 or more paths coming into or leaving it.
*   It is guaranteed an answer exists.


#### Solution

Language: **Python3**

```python3
class Solution:
    def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:
        dict_path={}
        for path in paths:
            if path[1]>path[0]:
                if path[0] not in dict_path:
                    dict_path[path[0]]=[path[1]]
                else:
                    dict_path[path[0]].append(path[1])
            else:
                if path[1] not in dict_path:
                    dict_path[path[1]]=[path[0]]
                else:
                    dict_path[path[1]].append(path[0])
                 
    
        dict_N={}
        for i in range(1,N+1):
            dict_N[i]=set()
        
​
        rep=[]
        for i in range(1,N+1):
            if not dict_N[i]:
                rep.append(1)
                if i in dict_path:
                    for path_end in dict_path[i]:
                        dict_N[path_end].add(1)
            else:
                for cur in range(1,5):
                    if cur not in dict_N[i]:
                        rep.append(cur)
                        if i in dict_path:
                            for path_end in dict_path[i]:
                                dict_N[path_end].add(cur)
                        break
        return rep
             
```
